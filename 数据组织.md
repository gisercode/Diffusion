### **完善后的数据处理流程规划 (最终版)**



#### **步骤 1: 初始加载、重塑与掩码创建**

1.  **加载数据**:
    - 加载各数据集的核心数据张量。
    - **统一重塑**: 将所有数据集统一为 `(N, T_total)` 的二维张量，称为 `raw_data`。
        - `metr_la`: 从 `(207, 119, 288)` 重塑为 `(207, 34272)`。
        - `pems_bay`: 从 `(325, 181, 288)` 重塑为 `(325, 52128)`。
        - `pm25`: 从 `(36, 365, 24)` 重塑为 `(36, 8760)`。

2.  **创建原始缺失掩码**:
    - 基于 `raw_data` 创建一个名为 `original_missing_mask` 的二进制掩码，维度为 `(N, T_total)`。
    - `raw_data` 中值为0的位置，在 `original_missing_mask` 中对应为1，其他位置为0。这个掩码是处理原始缺失的唯一依据。

#### **步骤 2: 数据集划分与归一化**

1.  **时间序列划分**:
    - 将 `raw_data` 和 `original_missing_mask` 这两个张量，严格按照时间顺序（沿 `T_total` 维度）划分为训练集、验证集和测试集。
    - 推荐比例：70% 训练，10% 验证，20% 测试。

2.  **数据归一化 (关键补充)**:
    - **计算统计量**: **仅在训练集 (`raw_data_train`) 上**计算每个站点（每行）的均值（mean）和标准差（std）。**注意：计算时应忽略原始缺失值（值为0的位置）**，以避免统计偏差。对于`metr_la`和`pems_bay`，可以直接加载提供的`meanstd.pk`文件。
    - **应用归一化**: 使用训练集计算出的均值和标准差，对训练集、验证集和测试集的所有数据进行Z-Score归一化：`data = (data - mean) / std`。
    - **目的**: 归一化是深度学习模型稳定训练的关键步骤，可以防止梯度爆炸或消失。将统计量计算限制在训练集上，是为了防止未来信息（验证/测试集）泄露到训练过程中。

#### **步骤 3: 生成样本窗口 (Sliding Window)**

1.  **定义窗口参数**:
    - `L_input`: 输入（历史）时间序列的长度 (e.g., 12)。
    - `L_pred`: 预测（未来）时间序列的长度 (e.g., 12)。
    - `L`: 样本窗口的总长度，`L = L_input + L_pred` (e.g., 24)。

2.  **滑动切片**:
    - 在归一化后的训练、验证、测试集上，以固定步长（`stride`）滑动一个长度为 `L` 的窗口。
    - 每一次滑动，都会切分出 `sample_raw_data` 和 `sample_original_missing_mask`，维度均为 `(N, L)`。
    - **实践建议**: `stride`可以设为1以最大化样本量，也可以设为大于1的值（如`L_pred`）来减少样本重叠和训练时间。

#### **步骤 4: 动态生成训练样本**

对于从上一步得到的每一个样本对 (`sample_raw_data`, `sample_original_missing_mask`)，动态执行以下操作：

1.  **初始化目标掩码**:
    - 创建一个全为0的 `target_mask`，维度为 `(N, L)`。

2.  **模拟预测任务 (Prediction)**:
    - 将 `target_mask` 中对应未来时间步 (`L_pred`) 的区域全部设为1。
    - `target_mask[:, L_input:] = 1`

3.  **模拟插值与重构任务 (Interpolation & Reconstruction)**:
    - 在**完整时间段 `[:, :L]`** 区域内引入人工缺失。
    - **设定缺失率 `P`** (例如 0.3)，代表新引入的缺失占历史窗口的比例。
    - **组合缺失模式**:
        - **a. 重构 (节点完全缺失)**: 以一个较小的概率 `p_node` (e.g., 0.1) 随机选择 `k` 个站点，将其在历史窗口内的 `target_mask` 值全部设为1。
        - **b. 块状缺失**: 对其他站点，以一定概率 `p_block` (e.g., 0.2) 随机选择连续时间段 `[i, j]`，并将对应区间的 `target_mask` 设为1。
        - **c. 随机缺失**: 在历史窗口内，随机选择一些位置设为1，直到 **`target_mask[:, :L]`** 中1的总比例达到 `P`。 
    - **策略说明**: 概率 `p_node` 和 `p_block` 可作为超参数，用于调整训练时对不同任务的侧重程度。

4.  **生成最终的输入和掩码**:
    - **`observed_mask`**: `observed_mask = 1 - target_mask`。
    - **`observed_data` (模型输入)**: `observed_data = sample_raw_data * observed_mask`。
    - **`loss_mask` (最终损失掩码)**:
        - `loss_mask = target_mask * (1 - sample_original_missing_mask)`。
        - 这一步的逻辑完美无缺，它精确地将损失计算限定在**我们希望模型生成**且**数据本身有效**的位置上。

